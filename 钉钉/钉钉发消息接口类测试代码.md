下面为你封装一个**面向对象的PHP钉钉个人消息发送类**，包含`access_token`缓存（避免重复调用接口）、多消息类型支持、发送结果查询等核心功能，同时提供完整的测试调用代码。该类遵循钉钉企业内部应用API规范，结构清晰且易于扩展。

### 一、前提条件
1. 已创建钉钉企业内部应用，获取`AppKey`、`AppSecret`、`AgentID`；
2. 已申请`message.corpconversation.asyncsend_v2`权限并通过企业审批；
3. 已将运行PHP脚本的服务器IP加入应用的IP白名单；
4. 已获取接收者的钉钉`userid`（多个用英文逗号分隔）。

### 二、钉钉个人消息发送类封装
创建文件`DingTalkPrivateMsg.php`，代码如下：
```php
<?php
/**
 * 钉钉企业内部应用-个人消息发送类
 * 支持文本、Markdown等消息类型，内置access_token缓存（有效期2小时）
 */
class DingTalkPrivateMsg
{
    // 钉钉开放平台基础接口地址
    const DING_API_BASE = 'https://oapi.dingtalk.com/';
    // access_token有效期（秒，钉钉官方为7200秒=2小时）
    const TOKEN_EXPIRE = 7000; // 预留200秒容错

    // 企业应用配置
    private $appKey;
    private $appSecret;
    private $agentId;

    // access_token缓存
    private $accessToken = null;
    private $tokenExpireTime = 0;

    /**
     * 构造函数：初始化企业应用配置
     * @param string $appKey 企业应用AppKey
     * @param string $appSecret 企业应用AppSecret
     * @param int $agentId 企业应用AgentID（数字类型）
     */
    public function __construct(string $appKey, string $appSecret, int $agentId)
    {
        $this->appKey = $appKey;
        $this->appSecret = $appSecret;
        $this->agentId = $agentId;
    }

    /**
     * 私有方法：发送CURL请求
     * @param string $apiPath 接口路径（如gettoken、topapi/message/corpconversation/asyncsend_v2）
     * @param array $params 请求参数（GET/POST）
     * @param string $method 请求方法（GET/POST）
     * @return array 接口返回的解析结果（含errcode/errmsg）
     */
    private function curlRequest(string $apiPath, array $params = [], string $method = 'GET'): array
    {
        $url = self::DING_API_BASE . ltrim($apiPath, '/');
        $ch = curl_init();

        // GET请求拼接参数
        if ($method === 'GET' && !empty($params)) {
            $url .= '?' . http_build_query($params);
        }

        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // 生产环境建议开启SSL验证
        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);
        curl_setopt($ch, CURLOPT_TIMEOUT, 10); // 请求超时时间

        // POST请求处理
        if ($method === 'POST' && !empty($params)) {
            curl_setopt($ch, CURLOPT_POST, true);
            curl_setopt($ch, CURLOPT_HTTPHEADER, [
                'Content-Type: application/json; charset=utf-8'
            ]);
            curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode($params, JSON_UNESCAPED_UNICODE));
        }

        $response = curl_exec($ch);
        $error = curl_error($ch);
        curl_close($ch);

        // 错误处理
        if ($error) {
            return ['errcode' => -1, 'errmsg' => 'CURL请求失败：' . $error];
        }

        $result = json_decode($response, true);
        return $result ?: ['errcode' => -2, 'errmsg' => 'JSON解析失败：' . $response];
    }

    /**
     * 公有方法：获取access_token（内置缓存，避免重复调用）
     * @return string|false 成功返回access_token，失败返回false
     */
    public function getAccessToken()
    {
        // 检查缓存的token是否有效
        if ($this->accessToken && $this->tokenExpireTime > time()) {
            return $this->accessToken;
        }

        // 调用钉钉获取token接口
        $result = $this->curlRequest('gettoken', [
            'appkey' => $this->appKey,
            'appsecret' => $this->appSecret
        ], 'GET');

        if (isset($result['errcode']) && $result['errcode'] === 0) {
            $this->accessToken = $result['access_token'];
            $this->tokenExpireTime = time() + self::TOKEN_EXPIRE; // 设置过期时间
            return $this->accessToken;
        } else {
            echo '获取access_token失败：' . ($result['errmsg'] ?? '未知错误') . PHP_EOL;
            return false;
        }
    }

    /**
     * 公有方法：发送个人消息（异步接口）
     * @param string $useridList 接收者userid列表（多个用英文逗号分隔，如"user1,user2"）
     * @param array $msg 消息体（格式：['msgtype' => 'text', 'text' => ['content' => '内容']]）
     * @param bool $enableDuplicateCheck 是否开启重复消息检查（默认true）
     * @param int $duplicateCheckInterval 重复检查间隔（秒，默认1800）
     * @return array 发送请求结果（含task_id/errcode/errmsg）
     */
    public function sendMessage(string $useridList, array $msg, bool $enableDuplicateCheck = true, int $duplicateCheckInterval = 1800): array
    {
        $accessToken = $this->getAccessToken();
        if (!$accessToken) {
            return ['errcode' => -3, 'errmsg' => 'access_token获取失败'];
        }

        // 构造发送参数
        $params = [
            'agent_id' => $this->agentId,
            'userid_list' => $useridList,
            'msg' => $msg,
            'enable_duplicate_check' => $enableDuplicateCheck,
            'duplicate_check_interval' => $duplicateCheckInterval
        ];

        // 调用异步发送接口
        $result = $this->curlRequest(
            'topapi/message/corpconversation/asyncsend_v2',
            $params,
            'POST'
        );

        return $result;
    }

    /**
     * 公有方法：查询消息发送结果（根据task_id）
     * @param string $taskId 发送消息返回的task_id
     * @return array 发送结果（含发送成功/失败的用户列表）
     */
    public function getSendResult(string $taskId): array
    {
        $accessToken = $this->getAccessToken();
        if (!$accessToken) {
            return ['errcode' => -3, 'errmsg' => 'access_token获取失败'];
        }

        $result = $this->curlRequest(
            'topapi/message/corpconversation/getsendresult',
            [
                'access_token' => $accessToken,
                'task_id' => $taskId,
                'agent_id' => $this->agentId
            ],
            'GET'
        );

        return $result;
    }
}
```

### 三、测试调用代码
创建文件`test_ding_msg.php`，代码如下（**需替换为自己的企业应用配置**）：
```php
<?php
require_once 'DingTalkPrivateMsg.php';

// -------------------------- 配置项（替换为自己的信息） --------------------------
$appKey = '你的企业应用AppKey';       // 如：dingabc1234567890
$appSecret = '你的企业应用AppSecret'; // 如：abcdefghijklmnopqrstuvwxyz123456
$agentId = 1234567;                   // 企业应用AgentID（数字）
$useridList = '你的钉钉用户ID';        // 如：'zhangsan,lisi'（多个用逗号分隔）
// -----------------------------------------------------------------------------

try {
    // 1. 实例化钉钉消息类
    $dingMsg = new DingTalkPrivateMsg($appKey, $appSecret, $agentId);

    // 2. 构造消息体（示例1：文本消息）
    $textMsg = [
        'msgtype' => 'text',
        'text' => [
            'content' => '【PHP类测试】这是一条企业内部应用发送的个人文本消息！' . date('Y-m-d H:i:s')
        ]
    ];

    // 3. 发送消息
    $sendResult = $dingMsg->sendMessage($useridList, $textMsg);
    echo "消息发送请求结果：\n";
    print_r($sendResult);
    echo "\n";

    // 4. 如果发送请求成功，查询实际发送结果（异步接口需查询）
    if (isset($sendResult['errcode']) && $sendResult['errcode'] === 0) {
        $taskId = $sendResult['result']['task_id'];
        echo "开始查询发送结果（task_id：{$taskId}）...\n";
        // 等待1秒再查询（避免钉钉还未处理完）
        sleep(1);
        $result = $dingMsg->getSendResult($taskId);
        echo "消息实际发送结果：\n";
        print_r($result);
    }

    // -------------------------- 扩展：发送Markdown消息 --------------------------
    /*
    $markdownMsg = [
        'msgtype' => 'markdown',
        'markdown' => [
            'title' => 'PHP类Markdown测试',
            'text' => "### 钉钉Markdown消息测试\n> 这是**加粗**的内容\n> 1. 列表项1\n> 2. 列表项2\n> [钉钉开放平台](https://open.dingtalk.com/)"
        ]
    ];
    $markdownResult = $dingMsg->sendMessage($useridList, $markdownMsg);
    echo "Markdown消息发送结果：\n";
    print_r($markdownResult);
    */

} catch (Exception $e) {
    echo '发送消息异常：' . $e->getMessage() . PHP_EOL;
}
```

### 四、代码说明
1. **类的核心特性**
   - **access_token缓存**：内置`tokenExpireTime`属性，缓存有效期内重复调用`getAccessToken()`会直接返回缓存的token，减少接口请求；
   - **多消息类型支持**：只需修改`$msg`参数的结构，即可发送文本、Markdown、链接、卡片等钉钉支持的消息类型；
   - **异步结果查询**：通过`getSendResult()`方法可查询消息的实际送达状态（钉钉`asyncsend_v2`是异步接口，返回`task_id`仅代表请求提交成功）；
   - **错误处理**：对CURL请求、JSON解析、token获取等环节做了错误捕获，返回明确的错误信息。

2. **运行方式**
   - 将两个文件放在同一目录下；
   - 替换`test_ding_msg.php`中的配置项为自己的企业应用信息；
   - 通过命令行（`php test_ding_msg.php`）或Web服务器运行该脚本。

### 五、常见问题排查
1. **错误码40001**：`access_token`无效，检查`AppKey`和`AppSecret`是否正确，或token是否过期；
2. **错误码40013**：`AgentID`错误，确认AgentID是数字类型且与企业应用一致；
3. **错误码403**：服务器IP未加入白名单，或应用未申请对应权限；
4. **错误码20006**：`userid`不存在或无权限发送，确认`userid`正确且用户在企业通讯录中。

如果需要支持更多消息类型（如链接、卡片），只需按照钉钉API文档构造对应的`$msg`数组即可，类的结构无需修改。
下面为你提供基于之前封装的`DingTalkPrivateMsg`类的**钉钉卡片消息（ActionCard）测试调用代码**，钉钉卡片消息分为**整体跳转卡片**和**独立按钮跳转卡片**两种核心类型，我会分别给出示例，并补充卡片消息的参数说明。

### 一、卡片消息测试调用代码
创建`test_ding_actioncard.php`文件，代码如下（需替换为你的企业应用配置）：
```php
<?php
require_once 'DingTalkPrivateMsg.php';

// -------------------------- 配置项（必须替换为自己的信息） --------------------------
$appKey = '你的企业应用AppKey';       // 如：dingabc1234567890
$appSecret = '你的企业应用AppSecret'; // 如：abcdefghijklmnopqrstuvwxyz123456
$agentId = 1234567;                   // 企业应用AgentID（数字类型）
$useridList = '你的钉钉用户ID';        // 单个用户：'zhangsan'，多个用户：'zhangsan,lisi'
// -----------------------------------------------------------------------------------

try {
    // 1. 实例化钉钉消息类
    $dingMsg = new DingTalkPrivateMsg($appKey, $appSecret, $agentId);

    /************************** 示例1：整体跳转卡片消息 **************************/
    echo "===== 发送整体跳转卡片消息 =====\n";
    // 构造整体跳转卡片消息体
    $singleActionCard = [
        'msgtype' => 'action_card',
        'action_card' => [
            'title' => '【系统通知】订单状态更新', // 卡片标题
            'text' => "### 订单支付成功通知\n\n"
                . "> 订单号：<font color=\"#FF5722\">NO.20251225001</font>\n\n"
                . "> 支付金额：<font color=\"#009688\">¥999.00</font>\n\n"
                . "> 支付时间：2025-12-25 10:00:00\n\n"
                . "> 状态：<font color=\"#1E90FF\">已支付，待发货</font>", // 卡片内容（支持Markdown）
            'btn_orientation' => '0', // 按钮排列方式：0-垂直，1-水平（整体跳转时该参数不影响）
            'single_title' => '点击查看订单详情', // 单个按钮的标题
            'single_url' => 'https://www.example.com/order/20251225001' // 点击跳转的链接
        ]
    ];

    // 发送整体跳转卡片消息
    $singleCardResult = $dingMsg->sendMessage($useridList, $singleActionCard);
    echo "整体跳转卡片发送请求结果：\n";
    print_r($singleCardResult);
    echo "\n";

    // 查询发送结果（异步接口需通过task_id查询）
    if (isset($singleCardResult['errcode']) && $singleCardResult['errcode'] === 0) {
        $taskId1 = $singleCardResult['result']['task_id'];
        sleep(1); // 等待钉钉处理请求
        $singleCardSendResult = $dingMsg->getSendResult($taskId1);
        echo "整体跳转卡片实际发送结果：\n";
        print_r($singleCardSendResult);
        echo "\n\n";
    }

    /************************** 示例2：独立按钮跳转卡片消息 **************************/
    echo "===== 发送独立按钮跳转卡片消息 =====\n";
    // 构造独立按钮卡片消息体
    $multiActionCard = [
        'msgtype' => 'action_card',
        'action_card' => [
            'title' => '【审批提醒】请假申请待处理', // 卡片标题
            'text' => "### 员工请假申请\n\n"
                . "> 申请人：张三\n\n"
                . "> 请假类型：年假\n\n"
                . "> 请假时长：3天（2025-12-26 至 2025-12-28）\n\n"
                . "> 申请理由：春节前回家探亲", // 卡片内容（支持Markdown）
            'btn_orientation' => '0', // 按钮排列方式：0-垂直，1-水平
            'btns' => [ // 多个独立按钮（最多支持4个）
                [
                    'title' => '同意申请',
                    'action_url' => 'https://www.example.com/approval/agree/1001'
                ],
                [
                    'title' => '拒绝申请',
                    'action_url' => 'https://www.example.com/approval/reject/1001'
                ],
                [
                    'title' => '查看详情',
                    'action_url' => 'https://www.example.com/approval/detail/1001'
                ]
            ]
        ]
    ];

    // 发送独立按钮卡片消息
    $multiCardResult = $dingMsg->sendMessage($useridList, $multiActionCard);
    echo "独立按钮卡片发送请求结果：\n";
    print_r($multiCardResult);
    echo "\n";

    // 查询发送结果
    if (isset($multiCardResult['errcode']) && $multiCardResult['errcode'] === 0) {
        $taskId2 = $multiCardResult['result']['task_id'];
        sleep(1);
        $multiCardSendResult = $dingMsg->getSendResult($taskId2);
        echo "独立按钮卡片实际发送结果：\n";
        print_r($multiCardSendResult);
    }

} catch (Exception $e) {
    echo '卡片消息发送异常：' . $e->getMessage() . PHP_EOL;
}
```

### 二、钉钉ActionCard卡片参数说明
| 参数名              | 类型       | 说明                                                                 |
|---------------------|------------|----------------------------------------------------------------------|
| `title`             | 字符串     | 卡片的标题（首屏展示）                                               |
| `text`              | 字符串     | 卡片内容，支持Markdown格式（如标题、加粗、字体颜色、引用等）          |
| `btn_orientation`   | 字符串     | 按钮排列方式：`0`为垂直排列，`1`为水平排列                           |
| `single_title`      | 字符串     | **整体跳转卡片专用**：单个按钮的标题                                 |
| `single_url`        | 字符串     | **整体跳转卡片专用**：点击按钮跳转的链接                             |
| `btns`              | 数组       | **独立按钮卡片专用**：按钮列表，最多支持4个按钮                      |
| `btns[].title`      | 字符串     | 独立按钮的标题                                                       |
| `btns[].action_url` | 字符串     | 点击独立按钮跳转的链接                                               |

### 三、运行注意事项
1. **配置替换**：必须将代码中的`$appKey`、`$appSecret`、`$agentId`、`$useridList`替换为你的企业应用实际信息；
2. **链接有效性**：`single_url`和`action_url`需填写可访问的真实链接，否则用户点击后会跳转到无效页面；
3. **Markdown支持**：`text`字段支持钉钉的Markdown子集（如标题、加粗、字体颜色、引用、列表等），具体可参考[钉钉官方Markdown规则](https://open.dingtalk.com/document/robots/markdown-syntax)；
4. **按钮数量限制**：独立按钮卡片的`btns`数组最多支持**4个按钮**，超出会导致消息发送失败；
5. **异步查询**：钉钉的`asyncsend_v2`是异步接口，返回`task_id`仅代表请求提交成功，需通过`getSendResult()`方法查询实际的消息送达状态。

### 四、效果预览
1. **整体跳转卡片**：展示标题和Markdown内容，底部有一个“点击查看订单详情”按钮，点击后跳转到指定链接；
2. **独立按钮卡片**：展示请假申请内容，底部垂直排列“同意申请”“拒绝申请”“查看详情”三个按钮，每个按钮对应不同的跳转链接。

如果需要调整卡片样式（如修改字体颜色、按钮排列方式），只需修改`text`中的Markdown内容或`btn_orientation`参数即可。