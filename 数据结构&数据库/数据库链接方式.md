你想了解的是数据库访问场景中，除了单例模式外的常用设计模式——这些模式主要解决数据库连接管理、查询优化、数据映射、事务处理等核心问题。我会按**使用频率+解决场景**分类，通俗讲解每种模式的作用、适用场景和简单实现思路（以Java为例，其他语言逻辑通用）。

### 一、数据库访问核心设计模式（除单例外）
#### 1. 工厂模式（Factory Pattern）
**核心作用**：统一创建数据库连接/操作对象，屏蔽不同数据库（MySQL/Oracle/PostgreSQL）的差异，降低耦合。
**适用场景**：系统需要适配多种数据库、或需要统一管理连接创建规则（比如不同环境用不同连接参数）。
**简单示例**：
```java
// 数据库连接工厂接口
public interface DBConnectionFactory {
    Connection createConnection();
}

// MySQL连接工厂实现
public class MySQLConnectionFactory implements DBConnectionFactory {
    @Override
    public Connection createConnection() {
        // 加载MySQL驱动、配置连接参数
        return DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "123456");
    }
}

// Oracle连接工厂实现
public class OracleConnectionFactory implements DBConnectionFactory {
    @Override
    public Connection createConnection() {
        return DriverManager.getConnection("jdbc:oracle:thin:@localhost:1521:ORCL", "root", "123456");
    }
}

// 使用：根据配置创建对应工厂，无需关心具体数据库类型
public class DBUtil {
    public static Connection getConnection(String dbType) {
        DBConnectionFactory factory;
        if ("mysql".equals(dbType)) {
            factory = new MySQLConnectionFactory();
        } else {
            factory = new OracleConnectionFactory();
        }
        return factory.createConnection();
    }
}
```

#### 2. 连接池模式（Connection Pool Pattern）
**核心作用**：预先创建一批数据库连接并缓存，避免频繁创建/销毁连接（数据库连接创建成本极高），提升性能。
**适用场景**：高并发系统（如电商、后台管理系统），是数据库访问的**标配模式**（几乎所有生产环境都会用）。
**常用实现**：无需自己写，直接用成熟组件：
- Java：HikariCP（性能最优）、C3P0、Druid（阿里，带监控）
- Python：DBUtils、SQLAlchemy连接池
- PHP：PDO连接池、Laravel数据库连接池
**简单使用示例（HikariCP）**：
```java
// 配置连接池
HikariConfig config = new HikariConfig();
config.setJdbcUrl("jdbc:mysql://localhost:3306/test");
config.setUsername("root");
config.setPassword("123456");
config.setMaximumPoolSize(10); // 最大连接数
config.setMinimumIdle(2); // 最小空闲连接数

// 创建连接池
HikariDataSource dataSource = new HikariDataSource(config);

// 从连接池获取连接（用完自动归还，无需手动关闭）
Connection conn = dataSource.getConnection();
```

#### 3. 数据访问对象模式（DAO Pattern）
**核心作用**：将数据库操作（CRUD）与业务逻辑分离，统一管理数据访问层，降低代码冗余。
**适用场景**：所有分层架构的系统（MVC/三层架构），是数据库访问的**基础规范**。
**结构**：
- DAO接口：定义该实体的CRUD方法（如UserDAO）
- DAO实现类：具体实现数据库操作（如UserDAOImpl）
- 实体类（Model）：对应数据库表结构（如User）
**示例**：
```java
// 实体类
public class User {
    private Long id;
    private String name;
    // getter/setter
}

// DAO接口
public interface UserDAO {
    User getById(Long id);
    void save(User user);
    void update(User user);
    void delete(Long id);
}

// DAO实现类（封装所有数据库操作）
public class UserDAOImpl implements UserDAO {
    private DataSource dataSource; // 依赖连接池

    @Override
    public User getById(Long id) {
        String sql = "SELECT id, name FROM user WHERE id = ?";
        try (Connection conn = dataSource.getConnection();
             PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setLong(1, id);
            ResultSet rs = pstmt.executeQuery();
            if (rs.next()) {
                User user = new User();
                user.setId(rs.getLong("id"));
                user.setName(rs.getString("name"));
                return user;
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        return null;
    }

    // 实现save/update/delete...
}

// 业务层调用（无需关心数据库操作细节）
public class UserService {
    private UserDAO userDAO = new UserDAOImpl();

    public User getUser(Long id) {
        return userDAO.getById(id); // 业务逻辑与数据库操作分离
    }
}
```

#### 4. 装饰器模式（Decorator Pattern）
**核心作用**：给数据库操作添加额外功能（如日志、缓存、事务、加密），不修改原有代码。
**适用场景**：需要扩展数据库操作功能，但不想侵入原有DAO逻辑（比如给查询加缓存、给增删改加日志）。
**示例（给DAO加日志装饰器）**：
```java
// 日志装饰器（实现UserDAO，包装原有DAO）
public class LoggedUserDAO implements UserDAO {
    private UserDAO targetDAO; // 被装饰的原始DAO

    public LoggedUserDAO(UserDAO targetDAO) {
        this.targetDAO = targetDAO;
    }

    @Override
    public User getById(Long id) {
        // 新增日志功能
        System.out.println("查询用户，ID：" + id + "，时间：" + new Date());
        // 调用原始DAO的方法
        return targetDAO.getById(id);
    }

    // 其他方法同理...
}

// 使用：包装原始DAO，新增功能
UserDAO userDAO = new LoggedUserDAO(new UserDAOImpl());
userDAO.getById(1L); // 自动打印日志
```

#### 5. 事务模式（Transaction Pattern）
**核心作用**：保证一组数据库操作（如转账：扣减A账户+增加B账户）要么全部成功，要么全部失败，避免数据不一致。
**适用场景**：涉及多步数据库操作的业务（转账、下单、库存扣减）。
**实现方式**：
- 手动管理：Connection.setAutoCommit(false) → 执行操作 → commit()/rollback()
- 框架封装：Spring @Transactional、MyBatis事务管理器
**示例（手动事务）**：
```java
public void transfer(Long fromId, Long toId, BigDecimal amount) {
    Connection conn = null;
    try {
        conn = dataSource.getConnection();
        conn.setAutoCommit(false); // 关闭自动提交

        // 扣减转出账户
        updateBalance(conn, fromId, amount.negate());
        // 增加转入账户
        updateBalance(conn, toId, amount);

        conn.commit(); // 全部成功，提交事务
    } catch (SQLException e) {
        if (conn != null) {
            try {
                conn.rollback(); // 失败回滚
            } catch (SQLException ex) {
                ex.printStackTrace();
            }
        }
        e.printStackTrace();
    } finally {
        if (conn != null) {
            try {
                conn.setAutoCommit(true); // 恢复自动提交
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 6. 仓储模式（Repository Pattern）
**核心作用**：比DAO模式更抽象，将数据访问封装为“仓储”，屏蔽底层数据源（数据库/缓存/文件），更贴合领域驱动设计（DDD）。
**适用场景**：复杂业务系统（如电商、金融），尤其是采用DDD架构的项目。
**与DAO的区别**：
- DAO：面向数据库表，操作粒度细（CRUD）；
- Repository：面向业务领域（如“用户仓储”“订单仓储”），包含业务语义（如findUserByPhone、findUnpaidOrders）。
**示例**：
```java
// 仓储接口（面向业务）
public interface UserRepository {
    User findByPhone(String phone);
    List<User> findActiveUsers(); // 业务语义：查询活跃用户
    void save(User user);
}

// 仓储实现（底层用DAO/ORM）
public class UserRepositoryImpl implements UserRepository {
    private UserDAO userDAO;

    @Override
    public User findByPhone(String phone) {
        // 底层调用DAO，封装业务查询逻辑
        return userDAO.queryByPhone(phone);
    }

    @Override
    public List<User> findActiveUsers() {
        // 封装“活跃用户”的查询规则（如最近7天登录）
        return userDAO.queryByCondition("last_login_time >= ?", LocalDateTime.now().minusDays(7));
    }

    // ...
}
```

### 二、其他常用辅助模式
| 模式 | 核心作用 | 适用场景 |
|------|----------|----------|
| 单例模式（补充） | 保证数据库连接池/配置类只有一个实例，避免重复创建 | 连接池、全局配置管理 |
| 代理模式 | 为数据库操作添加代理（如延迟加载、权限校验） | ORM框架（MyBatis/Hibernate）底层、权限控制 |
| 策略模式 | 动态切换查询策略（如不同条件用不同SQL） | 复杂查询场景（如多维度筛选） |
| 缓存模式 | 缓存高频查询结果，减少数据库访问 | 热点数据查询（如商品详情、用户信息） |

### 三、总结
1. **基础必备**：连接池模式（性能）+ DAO模式（分层）+ 事务模式（数据一致性），是所有数据库访问的核心；
2. **扩展优化**：工厂模式（多数据库适配）、装饰器模式（功能扩展）、缓存模式（性能优化）；
3. **架构升级**：仓储模式（DDD架构），适合复杂业务系统。

这些模式并非孤立使用，比如：连接池+DAO+事务+装饰器（日志）是生产环境的经典组合，而单例模式通常用于管理连接池实例（保证全局只有一个连接池）。