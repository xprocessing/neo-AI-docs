# **核心算法设计思想 (Paradigms)**

算法设计思想是解决一类问题的通用方法论和策略。理解这些范式有助于你分析问题并选择或创建最高效的解决方案。

## **1\. 基础与效率提升**

| 算法思想 | 英文名称 | 核心思想 | 典型应用 |
| :---- | :---- | :---- | :---- |
| **分治法** | Divide and Conquer | 将一个大问题分解为若干个相互独立、与原问题相似的子问题，递归地解决子问题，最后将子问题的解合并为原问题的解。 | 归并排序 (Merge Sort)、快速排序 (Quick Sort)、大整数乘法、二分搜索 (Binary Search)。 |
| **动态规划** | Dynamic Programming (DP) | 将一个复杂问题分解为相互重叠的子问题，通过存储和复用子问题的解（通常使用表格或数组），避免重复计算，从而解决原问题。**（空间换时间）** | 斐波那契数列、背包问题、最长公共子序列、矩阵链乘法。 |
| **贪心算法** | Greedy Algorithm | 在每一步选择中，都做出当前看来是最好的选择，期望通过局部最优解来达到全局最优解。**（不一定能得到全局最优）** | 霍夫曼编码 (Huffman Coding)、Prim 算法、Kruskal 算法（最小生成树）。 |

## **2\. 图形遍历与搜索**

| 算法思想 | 英文名称 | 核心思想 | 典型应用 |
| :---- | :---- | :---- | :---- |
| **深度优先搜索** | Depth-First Search (DFS) | 沿着树或图的某一路径一直走到底，如果无法继续，则回溯到上一个节点，探索其他路径。 | 图的连通性检查、拓扑排序、迷宫寻路。 |
| **广度优先搜索** | Breadth-First Search (BFS) | 从起始节点开始，逐层向外探索，先访问所有距离起点为 $k$ 的节点，再访问所有距离起点为 $k+1$ 的节点。 | 查找最短路径（无权图）、网络爬虫、社交网络分析。 |
| **回溯法** | Backtracking | 有条理地搜索问题的状态空间，尝试每一步的可能性。如果发现当前路径不可能达到目标，就立即“回溯”到上一步，放弃这条路径。**（本质是 DFS 的应用）** | N 皇后问题、排列组合问题、数独求解、着色问题。 |

## **3\. 数学与优化**

| 算法思想 | 英文名称 | 核心思想 | 典型应用 |
| :---- | :---- | :---- | :---- |
| **分支限界法** | Branch and Bound | 在搜索过程中，系统地检查问题的可行解空间，通过设定上下界（限界），剪除那些不可能产生最优解的分支，从而加速搜索。**（用于优化问题，通常结合 BFS/DFS）** | 旅行商问题 (TSP)、0/1 背包问题。 |
| **概率算法** | Randomized Algorithm | 算法的执行过程或输出结果依赖于随机数。可以用来简化问题、提高平均性能或解决无确定解的问题。 | 快速排序的随机主元选择、Monte Carlo 算法、Las Vegas 算法。 |
| **近似算法** | Approximation Algorithm | 当一个问题的精确解难以或无法在合理时间内求出时（如 NP-hard 问题），这种算法旨在快速找到一个接近最优解的解。 | 最小顶点覆盖问题、集合覆盖问题。 |

## **4\. 特殊技术**

| 算法思想 | 英文名称 | 核心思想 | 典型应用 |
| :---- | :---- | :---- | :---- |
| **迭代改进** | Iterative Improvement | 从一个初始解开始，通过反复应用一系列小的、局部的改进操作，逐步向最优解靠近，直到不能再改进为止。 | Simplex 算法（线性规划）、局部搜索算法。 |
| **启发式算法** | Heuristic Algorithm | 基于经验或直觉，而非严格数学推导，用于在搜索空间中高效找到一个“足够好”的解。通常用于优化和 AI 搜索。 | A\* 搜索算法（结合了 BFS 的优点和启发函数）。 |
| **摊还分析** | Amortized Analysis | 一种分析算法复杂度的技术，它不是看单个操作的最坏情况，而是计算一系列操作的平均成本，来确保最坏情况很少发生或被其它低成本操作摊平。 | 动态数组 (e.g., Python list append)、斐波那契堆。 |

这份列表涵盖了算法领域最核心的设计范式。掌握这些思想，就能更好地理解和设计高效的程序。